// # 3459. Length of Longest V-Shaped Diagonal Segment
// https://leetcode.com/problems/length-of-longest-v-shaped-diagonal-segment/

struct Solution;

impl Solution {
    pub fn len_of_v_diagonal(grid: Vec<Vec<i32>>) -> i32 {
        let m = grid.len() as i32;
        let n = grid[0].len() as i32;
        let mut max_len = 0;

        // Four diagonal directions: down-right, down-left, up-right, up-left
        let directions = [(1, 1), (1, -1), (-1, 1), (-1, -1)];

        // Try starting from each cell that has value 1
        for i in 0..m as usize {
            for j in 0..n as usize {
                if grid[i][j] == 1 {
                    // Try each diagonal direction
                    for dir_idx in 0..4 {
                        let start_dir = directions[dir_idx];

                        // Try without turn (straight line)
                        let straight_len =
                            Self::get_straight_length(&grid, i as i32, j as i32, start_dir);
                        max_len = max_len.max(straight_len);

                        // Try with clockwise turn to each other direction
                        for turn_idx in 0..4 {
                            if turn_idx != dir_idx {
                                let turn_dir = directions[turn_idx];
                                if Self::is_clockwise_turn(start_dir, turn_dir) {
                                    let v_len = Self::get_v_length(
                                        &grid, i as i32, j as i32, start_dir, turn_dir,
                                    );
                                    max_len = max_len.max(v_len);
                                }
                            }
                        }
                    }
                }
            }
        }

        max_len
    }

    fn get_straight_length(
        grid: &Vec<Vec<i32>>,
        start_i: i32,
        start_j: i32,
        dir: (i32, i32),
    ) -> i32 {
        let m = grid.len() as i32;
        let n = grid[0].len() as i32;

        let mut i = start_i;
        let mut j = start_j;
        let mut length = 0;
        let mut expected = 1; // Start with 1

        while i >= 0 && i < m && j >= 0 && j < n {
            if grid[i as usize][j as usize] != expected {
                break;
            }

            length += 1;
            expected = if expected == 1 {
                2
            } else if expected == 2 {
                0
            } else {
                2
            };

            i += dir.0;
            j += dir.1;
        }

        length
    }

    fn get_v_length(
        grid: &Vec<Vec<i32>>,
        start_i: i32,
        start_j: i32,
        dir1: (i32, i32),
        dir2: (i32, i32),
    ) -> i32 {
        let m = grid.len() as i32;
        let n = grid[0].len() as i32;

        let mut max_length = 0;

        // Try turning at each possible position along the first segment
        let mut i = start_i;
        let mut j = start_j;
        let mut expected = 1; // Start with 1
        let mut first_segment_len = 0;

        // Build first segment and try turning at each position
        while i >= 0 && i < m && j >= 0 && j < n {
            if grid[i as usize][j as usize] != expected {
                break;
            }

            first_segment_len += 1;

            // Try turning at this position
            let second_segment_len = Self::get_second_segment_length(&grid, i, j, dir2, expected);

            if second_segment_len > 1 {
                max_length = max_length.max(first_segment_len + second_segment_len - 1);
            }

            // Move to next position in first direction
            expected = if expected == 1 {
                2
            } else if expected == 2 {
                0
            } else {
                2
            };
            i += dir1.0;
            j += dir1.1;
        }

        max_length
    }

    fn get_second_segment_length(
        grid: &Vec<Vec<i32>>,
        start_i: i32,
        start_j: i32,
        dir: (i32, i32),
        first_expected: i32,
    ) -> i32 {
        let m = grid.len() as i32;
        let n = grid[0].len() as i32;

        let mut i = start_i;
        let mut j = start_j;
        let mut length = 1; // Count the turn position
        let mut expected = if first_expected == 1 {
            2
        } else if first_expected == 2 {
            0
        } else {
            2
        };

        // Move in the second direction
        i += dir.0;
        j += dir.1;

        while i >= 0 && i < m && j >= 0 && j < n {
            if grid[i as usize][j as usize] != expected {
                break;
            }

            length += 1;
            expected = if expected == 2 { 0 } else { 2 };

            i += dir.0;
            j += dir.1;
        }

        length
    }

    fn is_clockwise_turn(from: (i32, i32), to: (i32, i32)) -> bool {
        match from {
            (1, 1) => to == (1, -1),   // down-right to down-left
            (1, -1) => to == (-1, -1), // down-left to up-left
            (-1, -1) => to == (-1, 1), // up-left to up-right
            (-1, 1) => to == (1, 1),   // up-right to down-right
            _ => false,
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::hard::length_of_longest_v_shaped_diagonal_segment::Solution;

    #[test]
    fn test_len_of_v_diagonal_1() {
        let grid = [
            [2, 2, 1, 2, 2],
            [2, 0, 2, 2, 0],
            [2, 0, 1, 1, 0],
            [1, 0, 2, 2, 2],
            [2, 0, 0, 2, 2],
        ]
        .into_iter()
        .map(|l| l.to_vec())
        .collect::<Vec<Vec<i32>>>();
        assert_eq!(5, Solution::len_of_v_diagonal(grid));
    }

    #[test]
    fn test_len_of_v_diagonal_2() {
        let grid = [
            [2, 2, 2, 2, 2],
            [2, 0, 2, 2, 0],
            [2, 0, 1, 1, 0],
            [1, 0, 2, 2, 2],
            [2, 0, 0, 2, 2],
        ]
        .into_iter()
        .map(|l| l.to_vec())
        .collect::<Vec<Vec<i32>>>();
        assert_eq!(4, Solution::len_of_v_diagonal(grid));
    }

    #[test]
    fn test_len_of_v_diagonal_3() {
        let grid = [
            [1, 2, 2, 2, 2],
            [2, 2, 2, 2, 0],
            [2, 0, 0, 0, 0],
            [0, 0, 2, 2, 2],
            [2, 0, 0, 2, 0],
        ]
        .into_iter()
        .map(|l| l.to_vec())
        .collect::<Vec<Vec<i32>>>();
        assert_eq!(5, Solution::len_of_v_diagonal(grid));
    }

    #[test]
    fn test_len_of_v_diagonal_4() {
        let grid = [[1]]
            .into_iter()
            .map(|l| l.to_vec())
            .collect::<Vec<Vec<i32>>>();
        assert_eq!(1, Solution::len_of_v_diagonal(grid));
    }

    #[test]
    fn test_len_of_v_diagonal_5() {
        let grid = [
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 2, 2, 0, 2, 0, 0, 0, 0, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                1, 0, 2, 0, 2, 0, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 2, 2, 0, 2, 2, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 1, 1, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 1, 0, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 2, 2, 0, 2, 0, 2, 0, 0, 0, 2, 1, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 1, 0, 2, 0, 2, 1, 2, 1, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 2, 0, 2, 2, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0,
                2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 2, 1, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 2, 0,
                2, 1, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 1, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 1, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 2, 0, 2, 2, 0, 0, 2, 0, 2, 2, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 2, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                0,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 2, 0, 2, 0,
                0, 0, 2, 0, 2, 2, 2, 2, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 1, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 1, 0,
                2,
            ],
            [
                2, 0, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                2,
            ],
            [
                2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0,
                2, 0, 2, 1, 2, 0, 2, 0, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
                1,
            ],
        ]
        .into_iter()
        .map(|l| l.to_vec())
        .collect::<Vec<Vec<i32>>>();
        assert_eq!(52, Solution::len_of_v_diagonal(grid));
    }
}
